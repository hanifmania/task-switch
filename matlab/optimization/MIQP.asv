function [u_opt] = MIQP(xi,yi,u_nom,pos_con,theta_con,norm_con,xwidth_con,ywidth_con,f_con)

ConstraintNum = size(norm_con, 2);
dh_con = zeros(2,ConstraintNum);
hx_con = zeros(1,ConstraintNum);
coef = zeros(1,2);


for i=1:ConstraintNum
    %%% \partial x,yÇÃåvéZÇ…Ç†ÇΩÇËÅCã§í ÇÃåWêîÇæÇØêÊÇ…åvéZ
    coef(1) = -norm_con(i)*(((xi-pos_con(1,i))*cos(theta_con(i))...
        +(yi-pos_con(2,i))*sin(theta_con(i)))/xwidth_con(i)).^(norm_con(i)-1);
    coef(2) = -norm_con(i)*((-(xi-pos_con(1,i))*sin(theta_con(i))...
        +(yi-pos_con(2,i))*cos(theta_con(i)))/ywidth_con(i)).^(norm_con(i)-1);
    
    dh_con(:,i) = [coef(1)*cos(theta_con(i))/xwidth_con(i)+coef(2)*sin(theta_con(i))/ywidth_con(i);...
        coef(1)*sin(theta_con(i))/xwidth_con(i)+coef(2)*cos(theta_con(i))/ywidth_con(i)];
    hx_con(i) = (f_con{1,i}{1,1}(xi,yi)).^3;
end

h_f = f_con{1,1}{1,1}(xi,yi)-1+2^2; % CBF for flag: twice radius of main CBF
d_h_f = dh_con(:,1);

hinf = -100000;
hsup = 100000;
epsilon = max(1/1000000000,hx_con(1)/10000);
uinf = [-10000;-10000];
usup = [10000;10000];

A = [zeros(2,1) zeros(2,1) zeros(2) zeros(2) eye(2) -eye(2) zeros(2,1) zeros(2,ConstraintNum)]';
B = [-hinf -hsup-epsilon uinf' -usup' usup' -uinf' -h_f -hx_con]';
C = [zeros(2,1) zeros(2,1) -eye(2) eye(2) -eye(2) eye(2) -d_h_f(1) -dh_con]';
D = [-h_f+hinf h_f+epsilon zeros(2,1)' zeros(2,1)' -usup' uinf' zeros(1,:)]';

gQ = sparse([0.5*eye(2) zeros(2,1) zeros(2); zeros(1,5); zeros(2,5)]);
gc = [-u_nom; 0; zeros(2,1)];
gq = [A B C];

%% solve by gurobi
% Au + B\delta + Cz + D < 0
model.Q = gQ;
model.obj = gc;
model.modelsense = 'min';

model.A = sparse(gq);
model.rhs = -D;
model.sense = '<'; % '< 'means less or equal

model.vtype = 'CCBCC';
model.lb = [-inf -inf -inf -inf -inf];
params.OutputFlag = 0;
result = gurobi(model,params);
u_opt = result.x;

end

